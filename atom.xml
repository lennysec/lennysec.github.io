<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lenny&#39;s Blog</title>
  <icon>https://lennysec.github.io/icon.png</icon>
  
  <link href="https://lennysec.github.io/atom.xml" rel="self"/>
  
  <link href="https://lennysec.github.io/"/>
  <updated>2024-04-03T09:41:48.000Z</updated>
  <id>https://lennysec.github.io/</id>
  
  <author>
    <name>Lenny Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xz/liblzma 后门恶意代码注入方式分析</title>
    <link href="https://lennysec.github.io/xz-backdoor-code-injection-analysis/"/>
    <id>https://lennysec.github.io/xz-backdoor-code-injection-analysis/</id>
    <published>2024-04-03T09:41:48.000Z</published>
    <updated>2024-04-03T09:41:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;xz 后门爆出来之后，各路分析文章已经很多了，不过还是有些细节没有讲得很清楚，偶然看到四哥提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“作为围观群众，我在等待分析方展示一下，Hook 是怎么安装上去的，就是说 .so 被加载后，怎么就 call 到那个 .o 里去了，我问的是第一次。换句话说，是不是与 IFUNC 相关，究竟怎么完成第一步 Hook？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/KzIhfGwKygcKUrlN42dv-Q&quot;&gt;liblzma后门疑似国家级APT - 青衣十三楼飞花堂&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正好我跟四哥有同样的疑问，而且没有文章讲到这个问题，所以就来简单分析一下这个点，留作笔记。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Facebook Fizz memory leak vulnerability (CVE-2019-11924) reproduce and analysis</title>
    <link href="https://lennysec.github.io/fizz-memory-leak-analysis/"/>
    <id>https://lennysec.github.io/fizz-memory-leak-analysis/</id>
    <published>2020-03-30T06:36:59.000Z</published>
    <updated>2020-03-30T06:36:59.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Fizz is an open source TLS 1.3 implementation developed by Facebook. This post is about a memory leak vulnerability (CVE-2019-11924) in Fizz project. There’s almost no information about it on the internet other than a brief advisory and the patch commits on github. In this post, I’ll show you how to reproduce this vulnerability and make an analysis.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CodeQL 若干问题思考及 CVE-2019-3560 审计详解</title>
    <link href="https://lennysec.github.io/codql-and-cve-2019-3560/"/>
    <id>https://lennysec.github.io/codql-and-cve-2019-3560/</id>
    <published>2020-02-20T09:10:46.000Z</published>
    <updated>2020-02-20T09:10:46.000Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;CodeQL 是一个白盒源代码审计工具，去年在这一领域掀起了一些波澜。其开发公司 Semmle 也成功和 Github 联姻，成立了 Github Security Lab，负责 Github 上开源软件的代码安全审计。同时还推出了面向社区和企业的源代码分析服务平台 LGTM，一派生机勃勃的景象。不过国内安全社区对 CodeQL 似乎还没有足够的讨论，网上零星有几篇文章也主要是安装配置和简单上手体验。&lt;/p&gt;
&lt;p&gt;那么，CodeQL 有哪些核心能力？安全从业者能怎样运用它？它能给企业带来更大的价值吗？等等。这些都是我初见 CodeQL 时产生的疑问。在这篇文章中，我将从实际落地应用的角度出发，通过对一个漏洞实例的具体审计分析思路溯源来展示白盒审计中的一些关键问题，进而谈谈我对于 CodeQL 若干问题的个人看法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
