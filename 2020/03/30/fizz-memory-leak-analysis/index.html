<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-L.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-L.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-L.png">
  <link rel="mask-icon" href="/images/logo-L.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lenny233.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Fizz is an open source TLS 1.3 implementation developed by Facebook. This post is about a memory leak vulnerability (CVE-2019-11924) in Fizz project. There’s almost no information about it on the inte">
<meta property="og:type" content="article">
<meta property="og:title" content="Facebook Fizz memory leak vulnerability (CVE-2019-11924) reproduce and analysis">
<meta property="og:url" content="https://lenny233.github.io/2020/03/30/fizz-memory-leak-analysis/index.html">
<meta property="og:site_name" content="Lenny&#39;s Blog">
<meta property="og:description" content="Fizz is an open source TLS 1.3 implementation developed by Facebook. This post is about a memory leak vulnerability (CVE-2019-11924) in Fizz project. There’s almost no information about it on the inte">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://lenny233.github.io/images/blog_pic/2020-03-30_1.png">
<meta property="og:image" content="https://lenny233.github.io/images/blog_pic/2020-03-30_2.png">
<meta property="og:image" content="https://lenny233.github.io/images/blog_pic/2020-03-30_3.png">
<meta property="og:image" content="https://lenny233.github.io/images/blog_pic/2020-03-30_4.png">
<meta property="og:image" content="https://lenny233.github.io/images/blog_pic/2020-03-30_5.png">
<meta property="article:published_time" content="2020-03-30T06:36:59.000Z">
<meta property="article:modified_time" content="2020-03-30T07:58:15.470Z">
<meta property="article:author" content="lenny">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lenny233.github.io/images/blog_pic/2020-03-30_1.png">

<link rel="canonical" href="https://lenny233.github.io/2020/03/30/fizz-memory-leak-analysis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Facebook Fizz memory leak vulnerability (CVE-2019-11924) reproduce and analysis | Lenny's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Lenny's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lenny's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://lenny233.github.io/2020/03/30/fizz-memory-leak-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="lenny">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lenny's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Facebook Fizz memory leak vulnerability (CVE-2019-11924) reproduce and analysis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-30 14:36:59 / Modified: 15:58:15" itemprop="dateCreated datePublished" datetime="2020-03-30T14:36:59+08:00">2020-03-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Fizz is an open source TLS 1.3 implementation developed by Facebook. This post is about a memory leak vulnerability (CVE-2019-11924) in Fizz project. There’s almost no information about it on the internet other than a brief advisory and the patch commits on github. In this post, I’ll show you how to reproduce this vulnerability and make an analysis.</p>
<a id="more"></a>

<h2 id="Vulnerability-information"><a href="#Vulnerability-information" class="headerlink" title="Vulnerability information"></a>Vulnerability information</h2><p>The only information you can find about this vulnerability on the internet is as follow.</p>
<p><a href="https://www.facebook.com/security/advisories/cve-2019-11924" target="_blank" rel="noopener">A brief advisory</a> made by Facebook:</p>
<blockquote>
<p>Description: A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00.</p>
</blockquote>
<p>Two patch commits on github:</p>
<blockquote>
<p>Summary:<br>Zero length (all padding) handshake are forbidden by RFC. Allowing these was a regression in D13754697 (2c6f78a).</p>
<p>This is a partial fix for CVE-2019-11924</p>
</blockquote>
<p><a href="https://github.com/facebookincubator/fizz/commit/6bf67137ef1ee5cd70c842b014c322b7deaf994b" target="_blank" rel="noopener">This commit</a> patched the <code>EncryptedReadRecordLayer::read()</code> function.</p>
<blockquote>
<p>Summary:<br>It is possible that a peer might send us records in a manner such that there is a 16KB record and only 1 byte of handshake message in each record. Since we normally just trim the IOBuf, we would end up holding 16K of data per actual byte of data. To prevent this we allocate a contiguous buffer to copy over these bytes for handshake messages for now.</p>
<p>This is a partial fix for CVE-2019-11924</p>
</blockquote>
<p><a href="https://github.com/facebookincubator/fizz/commit/3eaddb33619eaaf74a760872850c550ad8f5c52f" target="_blank" rel="noopener">This commit</a> patched the <code>ReadRecordLayer::readEvent()</code> function.</p>
<p>We can get a few key points about the vulnerability according to the patch commits:</p>
<ol>
<li>It causes memory leak problem;</li>
<li>It occurs during TLS 1.3 handshake procedure;</li>
<li>Zero length (all padding) handshake message can trigger it;</li>
<li>It is related to encrypted message rather than plaintext message.</li>
</ol>
<h2 id="Reproduce-the-vulnerability"><a href="#Reproduce-the-vulnerability" class="headerlink" title="Reproduce the vulnerability"></a>Reproduce the vulnerability</h2><p>In this section, I’ll show you how to reproduce this vulnerability.</p>
<h3 id="TLS-1-3-Handshake-overview"><a href="#TLS-1-3-Handshake-overview" class="headerlink" title="TLS 1.3 Handshake overview"></a>TLS 1.3 Handshake overview</h3><p>First of all, we need to know more about the TLS 1.3 handshake procedure. The purpose of handshake in TLS is to negotiate a protocol version, select cryptographic algorithms, optionally authenticate each other, and establish shared secret keying material between client and server. According to <code>RCF 8446</code>, the basic message flow for full TLS handshake is as follow:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">       Client                                           Server</span><br><span class="line"></span><br><span class="line">Key  ^ ClientHello</span><br><span class="line">Exch | + key_share*</span><br><span class="line">     | + signature_algorithms*</span><br><span class="line">     | + psk_key_exchange_modes*</span><br><span class="line">     v + pre_shared_key*       --------&gt;</span><br><span class="line">                                                  ServerHello  ^ Key</span><br><span class="line">                                                 + key_share*  | Exch</span><br><span class="line">                                            + pre_shared_key*  v</span><br><span class="line">                                        &#123;EncryptedExtensions&#125;  ^  Server</span><br><span class="line">                                        &#123;CertificateRequest*&#125;  v  Params</span><br><span class="line">                                               &#123;Certificate*&#125;  ^</span><br><span class="line">                                         &#123;CertificateVerify*&#125;  | Auth</span><br><span class="line">                                                   &#123;Finished&#125;  v</span><br><span class="line">                               &lt;--------  [Application Data*]</span><br><span class="line">     ^ &#123;Certificate*&#125;</span><br><span class="line">Auth | &#123;CertificateVerify*&#125;</span><br><span class="line">     v &#123;Finished&#125;              --------&gt;</span><br><span class="line">       [Application Data]      &lt;-------&gt;  [Application Data]</span><br><span class="line"></span><br><span class="line">+  Indicates noteworthy extensions sent in the previously noted message.</span><br><span class="line">*  Indicates optional or situation-dependent messages&#x2F;extensions that are not always sent.</span><br><span class="line">&#123;&#125; Indicates messages protected using keys derived from a [sender]_handshake_traffic_secret.</span><br><span class="line">[] Indicates messages protected using keys derived from [sender]_application_traffic_secret_N.</span><br></pre></td></tr></table></figure>

<p>As you can see, there are many different types of messages during handshake procedure. The question is which specific message can trigger the vulnerability?</p>
<p>In TLS 1.3, all handshake messages after the <code>Server Hello</code> are now encrypted. According to my conclusion in the vulnerability information section, the <code>Client Finished</code> message seems to be the answer.</p>
<h3 id="Normal-Client-Finished-message"><a href="#Normal-Client-Finished-message" class="headerlink" title="Normal Client Finished message"></a>Normal Client Finished message</h3><p>TLS consists of two primary components:</p>
<p>Handshake protocol: Authenticates the communicating parties, negotiates cryptographic modes and parameters, and establishes shared keying material.</p>
<p>Record protocol: Uses the parameters established by the handshake protocol to protect traffic between the communicating peers. The record protocol divides traffic up into a series of records, each of which is independently protected using the traffic keys.</p>
<p>In this section, I’ll show you what a normal <code>Client Finished</code> message looks like and how it is generated.</p>
<h4 id="Client-Finished-message-in-handshake-layer"><a href="#Client-Finished-message-in-handshake-layer" class="headerlink" title="Client Finished message in handshake layer"></a>Client Finished message in handshake layer</h4><p>Here is an example of plaintext <code>Client Finished</code> message.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x14 0x00 0x00 0x30</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Handshake Header</span><br><span class="line">&#x2F;&#x2F; 0x14 - handshake message type 0x14 (finished)</span><br><span class="line">&#x2F;&#x2F; 0x00 0x00 0x30 - 0x30 (48) bytes of handshake finished data follow</span><br><span class="line"></span><br><span class="line">0x38 0x41 0x86 0x0a 0x64 0x5c 0x35 0x51 0x98 0x7b 0x01 0x3a</span><br><span class="line">0x93 0xf7 0xdd 0x5b 0x38 0x76 0xb7 0x7c 0x7b 0x13 0xea 0x7b 0x59 0xb0 0x4f 0x29</span><br><span class="line">0x3f 0x8f 0xd1 0x14 0xb7 0x5f 0x50 0x7b 0xe5 0xef 0x9a 0x5c 0xc0 0xf3 0x39 0x7d</span><br><span class="line">0x58 0x24 0xd0 0xa9</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Verify Data</span><br></pre></td></tr></table></figure>

<p>The structure of it can be divided into two parts.</p>
<p>It starts with four bytes of <code>Handshake Header</code>. Each handshake message starts with a type and a length. The rest of the message is <code>verify_data</code> which is computed as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">verify_data &#x3D; HMAC(</span><br><span class="line">    finished_key,</span><br><span class="line">    Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">* Only included if present.</span><br></pre></td></tr></table></figure>

<p>The <code>finished_key</code> is computed from the <code>BaseKey</code> using <code>HKDF-Expand</code> function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finished_key &#x3D; HKDF-Expand-Label(BaseKey, &quot;finished&quot;, &quot;&quot;, Hash.length)</span><br></pre></td></tr></table></figure>

<p>The BaseKey for <code>Client Finished</code> message is <code>client_handshake_traffic_secret</code> which is calculated in the previous cryptographic negotiation steps.</p>
<h4 id="Client-Finished-message-in-record-layer"><a href="#Client-Finished-message-in-record-layer" class="headerlink" title="Client Finished message in record layer"></a>Client Finished message in record layer</h4><p>In record layer, the plaintext <code>Client Finished</code> message will be encrypted.</p>
<p>The structure of a encrypted TLS 1.3 record is as follow:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    ContentType opaque_type &#x3D; application_data; &#x2F;* 23 *&#x2F;</span><br><span class="line">    ProtocolVersion legacy_record_version &#x3D; 0x0303; &#x2F;* TLS v1.2 *&#x2F;</span><br><span class="line">    uint16 length;</span><br><span class="line">    opaque encrypted_record[TLSCiphertext.length];</span><br><span class="line">&#125; TLSCiphertext;</span><br></pre></td></tr></table></figure>

<p>Here ia an example of an encrypted TLS record.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x17 0x03 0x03 0x00 0x45</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Record Header</span><br><span class="line">&#x2F;&#x2F; The TLS 1.3 record is encrypted into a TLS 1.2 record &quot;wrapper&quot; that looks like application data.</span><br><span class="line">&#x2F;&#x2F; 0x17 - type is 0x17 (application data)</span><br><span class="line">&#x2F;&#x2F; 0x03 0x03 - legacy protocol version of &quot;3,3&quot; (TLS 1.2)</span><br><span class="line">&#x2F;&#x2F; 0x00 0x45 - 0x45 (69) bytes of wrapped data follows</span><br><span class="line"></span><br><span class="line">0x3e 0xbf 0x4b 0xf2 0xf7 0x18 0xfb 0xee 0x06 0xf7 0x7d 0xbd 0x43 0xa2 0xde 0xe5</span><br><span class="line">0xe3 0x41 0x54 0xdc 0xf2 0x89 0x1b 0xd7 0xa1 0x57 0x9e 0xb0 0xee 0xe6 0x11 0x8e</span><br><span class="line">0x29 0x7e 0xc6 0x21 0x72 0x23 0xcf 0x6c 0x5a 0x24 0xfa 0xa6 0x77 0x43 0x32 0x71</span><br><span class="line">0x01 0xe3 0x37 0xd2 0x18</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Encrypted Data</span><br><span class="line">&#x2F;&#x2F; This data is encrypted with the client handshake key.</span><br><span class="line"></span><br><span class="line">0xc8 0x19 0x07 0x3b 0xe2 0x76 0xe5 0xf9 0xa7 0x3f 0x40 0x7b 0x27 0x06 0xff 0x96</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Auth Tag</span><br><span class="line">&#x2F;&#x2F; This is the AEAD authentication tag that protects the integrity of the encrypted data and the record header.</span><br></pre></td></tr></table></figure>

<p>The <code>encrypted_record</code> is computed as follow:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AEADEncrypted &#x3D; AEAD-Encrypt(write_key, nonce, additional_data, plaintext)</span><br></pre></td></tr></table></figure>

<p>The write_key here is <code>client_write_key</code> which is is calculated in the previous cryptographic negotiation steps. The <code>nonce</code> is a random number which is derived from the sequence number and the <code>client_write_iv</code>.</p>
<h3 id="Crafted-Client-Finished-message"><a href="#Crafted-Client-Finished-message" class="headerlink" title="Crafted Client Finished message"></a>Crafted Client Finished message</h3><p>To trigger the vulnerability, we need to construct a Client Finished message that satisfies the following conditions:</p>
<ol>
<li>It’s must be a valid handshake message;</li>
<li>It can be decrypted correctly by server;</li>
<li>It’s not a real <code>Client Finished</code> message. Otherwise it can only be received once.</li>
<li>It’s not empty, but in the meanwhile the length of it should be 0.</li>
</ol>
<p>How this can be done? After several attempts, I found the right way. The message structure we need to modify is the <code>TLSPlaintext</code>. The normal <code>TLSPlaintext</code> structure is as follow:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    ContentType type;</span><br><span class="line">    ProtocolVersion legacy_record_version;</span><br><span class="line">    uint16 length;</span><br><span class="line">    opaque fragment[TLSPlaintext.length];</span><br><span class="line">&#125; TLSPlaintext;</span><br></pre></td></tr></table></figure>

<p>The crafted <code>TLSPlaintext</code> can be described as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytearray(b&#39;\x16&#39;) + bytearray(b&#39;\x00&#39; * 1024 * 16)</span><br></pre></td></tr></table></figure>

<p>It’s simply a byte of ContentType (0x16 indicates handshake) followed by 16K bytes of 0x00 (padding). 16K is the maximum size of TLS record size. It’s a valid TLS record, but not a real <code>Client Finished</code> message. After that, the message should be encrypted to <code>TLSCiphertext</code> correctly and then send to server.</p>
<p>Note: Except for the modification to <code>TLSPlaintext</code>, everything else should follow the TLS 1.3 protocol standards.</p>
<h4 id="How-dose-Fizz-server-determine-the-length-of-encrypted-message"><a href="#How-dose-Fizz-server-determine-the-length-of-encrypted-message" class="headerlink" title="How dose Fizz server determine the length of encrypted message"></a>How dose Fizz server determine the length of encrypted message</h4><p>As I mentioned above, our goal is to make the message not empty, but in the meanwhile the length is 0. Why does an all padding handshake message can do this?</p>
<p>The encrypted message will be decrypted and assigned to a <code>TLSMessage</code> variable when server received it from socket. Let’s dive into the <code>TLSMessage</code> variable assignment logic in Fizz sever. The related code is in the <a href="https://github.com/facebookincubator/fizz/blob/29b79d436fd7e0ce324ff3fd3d4c3bb557a8d86d/fizz/record/EncryptedRecordLayer.cpp#L116" target="_blank" rel="noopener">EncryptedReadRecordLayer::read()</a> function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TLSMessage msg;</span><br><span class="line"><span class="keyword">auto</span> currentBuf = decryptedBuf-&gt;<span class="built_in">get</span>();</span><br><span class="line"><span class="keyword">bool</span> nonZeroFound = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    currentBuf = currentBuf-&gt;prev();</span><br><span class="line">    <span class="keyword">size_t</span> i = currentBuf-&gt;length();</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; !nonZeroFound) &#123;</span><br><span class="line">        nonZeroFound = (currentBuf-&gt;data()[i - <span class="number">1</span>] != <span class="number">0</span>);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nonZeroFound) &#123;</span><br><span class="line">        msg.type = <span class="keyword">static_cast</span>&lt;ContentType&gt;(currentBuf-&gt;data()[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    currentBuf-&gt;trimEnd(currentBuf-&gt;length() - i);</span><br><span class="line">&#125; <span class="keyword">while</span> (!nonZeroFound &amp;&amp; currentBuf != decryptedBuf-&gt;<span class="built_in">get</span>());</span><br><span class="line"><span class="keyword">if</span> (!nonZeroFound) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"No content type found"</span>);</span><br><span class="line">&#125;</span><br><span class="line">msg.fragment = <span class="built_in">std</span>::<span class="built_in">move</span>(*decryptedBuf);</span><br></pre></td></tr></table></figure>

<p>First, the encrypted message will be decrypted to <code>decryptedBuf</code>:</p>
<p><img src="/images/blog_pic/2020-03-30_1.png" alt="01"></p>
<p>What this piece of code does is basically iterating over the <code>decryptedBuf</code> from end to start while trying to find the first non-zero byte. Assign the first non-zero byte to <code>msg.type</code> (MessageType byte is in the buffer end after decryption). Then, <code>folly::IOBuf::trimEnd()</code> is called to trim the 0x00 bytes in the end of the buffer. Finlay, the trimmed buffer is assigned to <code>msg.fragment</code>.</p>
<p><code>msg.fragment</code> is a <code>folly::IOBuf</code> object whose length is a class variable managed by the class itself. <code>folly:IOBuf::trimEnd()</code> function is as follow:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimEnd</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> amount)</span> </span>&#123;</span><br><span class="line">    DCHECK_LE(amount, length_);</span><br><span class="line">    length_ -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, the <code>trimEnd</code> operation just adjust the tail pointer and does not modify any actual data in the buffer. Thus, the length of <code>msg.fragment</code> is 0, but it actually holds 16K of data.</p>
<p><img src="/images/blog_pic/2020-03-30_2.png" alt="02"></p>
<h4 id="The-memory-leak-problem"><a href="#The-memory-leak-problem" class="headerlink" title="The memory leak problem"></a>The memory leak problem</h4><p>A complete attack flow can be described as follow:</p>
<ol>
<li>A client follows the TLS 1.3 protocol standards;</li>
<li>Send crafted <code>Client Finished</code> repeatedly at the normal <code>Client Finished</code> message sending procedure.</li>
</ol>
<p>At server side, you will see the memory usage of Fizz server process is growing rapidly. In my test, the crafted <code>Client Finished</code> message was sended for 10000 times.</p>
<p>The initial memory usage of Fizz server process is about 13M:</p>
<p><img src="/images/blog_pic/2020-03-30_3.png" alt="03"></p>
<p>After 10000 times of the crafted <code>Client Finished</code> message sending, the memory usage is about 210M:</p>
<p><img src="/images/blog_pic/2020-03-30_4.png" alt="04"></p>
<h2 id="Root-cause-analysis"><a href="#Root-cause-analysis" class="headerlink" title="Root cause analysis"></a>Root cause analysis</h2><p>The memory leak problem exists in <a href="https://github.com/facebookincubator/fizz/blob/29b79d436fd7e0ce324ff3fd3d4c3bb557a8d86d/fizz/record/RecordLayer.cpp#L51" target="_blank" rel="noopener">ReadRecordLayer::readEvent()</a> function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ContentType::handshake: &#123;</span><br><span class="line">    unparsedHandshakeData_.append(<span class="built_in">std</span>::<span class="built_in">move</span>(message-&gt;fragment));</span><br><span class="line">    <span class="keyword">auto</span> param = decodeHandshakeMessage(unparsedHandshakeData_);</span><br><span class="line">    <span class="keyword">if</span> (param) &#123;</span><br><span class="line">        VLOG(<span class="number">8</span>) &lt;&lt; <span class="string">"Received handshake message "</span></span><br><span class="line">                &lt;&lt; toString(boost::apply_visitor(EventVisitor(), *param));</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>unparsedHandshakeData_</code> here is a <code>folly::IOBufQueue</code> object which is basically a chain of <code>folly:IOBuf</code> objects. Every new message is appended to <code>unparsedHandshakeData_</code>, and normally the memory is freed after the handshake message was decoded.</p>
<p>In this attack scenario, Fizz server is waiting a <code>Client Finished</code> message to finish the handshake procedure. But we send a crafted message which is not a real <code>Client Finished</code> message. Fizz server will stuck in the handshake message read event loop because the handshake procedure is not done.</p>
<p>Furthermore, the memory free logic in <code>decodeHandshakeMessage()</code> cannot be reached because every <code>message-&gt;fragment</code> (<code>folly::IOBuf</code> object) appended to <code>unparsedHandshakeData_</code> is 0 length. Another important thing is that the <code>message-&gt;fragment</code> actually holds 16K memory data (as I explained above), even if the length of it is 0.</p>
<p>Taking all the above factors into consideration, the memory leak problem is easy to understand.</p>
<h2 id="Patch-analysis"><a href="#Patch-analysis" class="headerlink" title="Patch analysis"></a>Patch analysis</h2><p>The official patch fixes two functions. For the memory leak problem in <a href="https://github.com/facebookincubator/fizz/commit/3eaddb33619eaaf74a760872850c550ad8f5c52f?diff=unified#diff-d34d9d689acc6106c99b670cbf357a31" target="_blank" rel="noopener">ReadRecordLayer::readEvent()</a>, the patch code is as follow:</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-    unparsedHandshakeData_.append(std::move(message-&gt;fragment));</span></span><br><span class="line"><span class="addition">+    std::unique_ptr&lt;folly::IOBuf&gt; handshakeMessage =</span></span><br><span class="line"><span class="addition">+        unparsedHandshakeData_.move();</span></span><br><span class="line"><span class="addition">+    message-&gt;fragment-&gt;coalesce();</span></span><br><span class="line"><span class="addition">+    constexpr size_t kExtraAlloc = 1024;</span></span><br><span class="line"><span class="addition">+    if (!handshakeMessage) &#123;</span></span><br><span class="line"><span class="addition">+        handshakeMessage =</span></span><br><span class="line"><span class="addition">+            folly::IOBuf::create(message-&gt;fragment-&gt;length() + kExtraAlloc);</span></span><br><span class="line"><span class="addition">+    &#125; else if (handshakeMessage-&gt;tailroom() &lt; message-&gt;fragment-&gt;length()) &#123;</span></span><br><span class="line"><span class="addition">+        handshakeMessage-&gt;reserve(</span></span><br><span class="line"><span class="addition">+            0, message-&gt;fragment-&gt;length() + kExtraAlloc);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    memcpy(</span></span><br><span class="line"><span class="addition">+        handshakeMessage-&gt;writableTail(),</span></span><br><span class="line"><span class="addition">+        message-&gt;fragment-&gt;data(),</span></span><br><span class="line"><span class="addition">+        message-&gt;fragment-&gt;length());</span></span><br><span class="line"><span class="addition">+    handshakeMessage-&gt;append(message-&gt;fragment-&gt;length());</span></span><br><span class="line"><span class="addition">+    unparsedHandshakeData_.append(std::move(handshakeMessage));</span></span><br></pre></td></tr></table></figure>

<p>The new code allocate a contiguous buffer to copy over these bytes. In addition, kExtraAlloc bytes is applied in order to avoid needing to re-allocate a lot of times if we receive a lot of small messages. So the maximum memory usage is <code>length + kExtraAlloc</code>. Here is a an example of the result for an all padding handshake massage:</p>
<p><img src="/images/blog_pic/2020-03-30_5.png" alt="05"></p>
<p>The fix in <a href="https://github.com/facebookincubator/fizz/commit/6bf67137ef1ee5cd70c842b014c322b7deaf994b?diff=unified#diff-15ccf99d5d34c4f7e84571f1c75f7309" target="_blank" rel="noopener">EncryptedReadRecordLayer::read()</a> is more fundamental. It rejects zero length (all padding) handshake message directly because it is forbidden by RFC.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-   if (!msg.fragment) &#123;</span></span><br><span class="line"><span class="addition">+   if (!msg.fragment || msg.fragment-&gt;empty()) &#123;</span></span><br><span class="line">    if (msg.type == ContentType::application_data) &#123;</span><br><span class="line">        msg.fragment = folly::IOBuf::create(0);</span><br><span class="line">    &#125; else &#123;</span><br></pre></td></tr></table></figure>

<p>The RFC 8446 says and I quote in section <a href="https://tools.ietf.org/html/rfc8446#section-5.4" target="_blank" rel="noopener">5.4. Record Padding</a>:</p>
<blockquote>
<p>Application Data records may contain a zero-length TLSInnerPlaintext.content if the sender desires.  This permits generation of plausibly sized cover traffic in contexts where the presence or absence of activity may be sensitive. Implementations MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content; if such a message is received, the receiving implementation MUST terminate the connection with an “unexpected_message” alert.</p>
</blockquote>
<p>OK, That’s all for this post. During my research, I found some very useful resources, and I listed them at the reference section. Have fun.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><p>RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3<br><a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc8446</a></p>
</li>
<li><p>The New Illustrated TLS Connection<br><a href="https://tls13.ulfheim.net/" target="_blank" rel="noopener">https://tls13.ulfheim.net/</a></p>
</li>
<li><p>Awesome SSL/TLS Hacks<br><a href="https://github.com/lenny233/awesome-tls-hacks" target="_blank" rel="noopener">https://github.com/lenny233/awesome-tls-hacks</a></p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/20/codql-and-cve-2019-3560/" rel="prev" title="CodeQL 若干问题思考及 CVE-2019-3560 审计详解">
      <i class="fa fa-chevron-left"></i> CodeQL 若干问题思考及 CVE-2019-3560 审计详解
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vulnerability-information"><span class="nav-number">1.</span> <span class="nav-text">Vulnerability information</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reproduce-the-vulnerability"><span class="nav-number">2.</span> <span class="nav-text">Reproduce the vulnerability</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TLS-1-3-Handshake-overview"><span class="nav-number">2.1.</span> <span class="nav-text">TLS 1.3 Handshake overview</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Normal-Client-Finished-message"><span class="nav-number">2.2.</span> <span class="nav-text">Normal Client Finished message</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Client-Finished-message-in-handshake-layer"><span class="nav-number">2.2.1.</span> <span class="nav-text">Client Finished message in handshake layer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Client-Finished-message-in-record-layer"><span class="nav-number">2.2.2.</span> <span class="nav-text">Client Finished message in record layer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Crafted-Client-Finished-message"><span class="nav-number">2.3.</span> <span class="nav-text">Crafted Client Finished message</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#How-dose-Fizz-server-determine-the-length-of-encrypted-message"><span class="nav-number">2.3.1.</span> <span class="nav-text">How dose Fizz server determine the length of encrypted message</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-memory-leak-problem"><span class="nav-number">2.3.2.</span> <span class="nav-text">The memory leak problem</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Root-cause-analysis"><span class="nav-number">3.</span> <span class="nav-text">Root cause analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Patch-analysis"><span class="nav-number">4.</span> <span class="nav-text">Patch analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">5.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lenny"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">lenny</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://weibo.com/lywang90" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;lywang90" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/lywang90" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;lywang90" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-bolt"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lenny</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
