<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-L.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-L.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-L.png">
  <link rel="mask-icon" href="/images/logo-L.png" color="#222">
  <meta name="google-site-verification" content="OOxvZddasMwr7ubNOm8k2gmOjGgUZsb8_ODXON_JXo4">
  <meta name="msvalidate.01" content="5384DD95072D960F10ED5A1EF29A7D8E">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lennysec.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. 背景CodeQL 是一个白盒源代码审计工具，去年在这一领域掀起了一些波澜。其开发公司 Semmle 也成功和 Github 联姻，成立了 Github Security Lab，负责 Github 上开源软件的代码安全审计。同时还推出了面向社区和企业的源代码分析服务平台 LGTM，一派生机勃勃的景象。不过国内安全社区对 CodeQL 似乎还没有足够的讨论，网上零星有几篇文章也主要是安装配置和">
<meta property="og:type" content="article">
<meta property="og:title" content="CodeQL 若干问题思考及 CVE-2019-3560 审计详解">
<meta property="og:url" content="https://lennysec.github.io/codql-and-cve-2019-3560/index.html">
<meta property="og:site_name" content="Lenny&#39;s Blog">
<meta property="og:description" content="1. 背景CodeQL 是一个白盒源代码审计工具，去年在这一领域掀起了一些波澜。其开发公司 Semmle 也成功和 Github 联姻，成立了 Github Security Lab，负责 Github 上开源软件的代码安全审计。同时还推出了面向社区和企业的源代码分析服务平台 LGTM，一派生机勃勃的景象。不过国内安全社区对 CodeQL 似乎还没有足够的讨论，网上零星有几篇文章也主要是安装配置和">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://lennysec.github.io/images/blog_pic/2020-02-20_1.png">
<meta property="og:image" content="https://lennysec.github.io/images/blog_pic/2020-02-20_2.png">
<meta property="article:published_time" content="2020-02-20T09:10:46.000Z">
<meta property="article:modified_time" content="2020-02-20T09:10:46.000Z">
<meta property="article:author" content="Lenny Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lennysec.github.io/images/blog_pic/2020-02-20_1.png">

<link rel="canonical" href="https://lennysec.github.io/codql-and-cve-2019-3560/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CodeQL 若干问题思考及 CVE-2019-3560 审计详解 | Lenny's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Lenny's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lenny's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lennysec.github.io/codql-and-cve-2019-3560/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Lenny Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lenny's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CodeQL 若干问题思考及 CVE-2019-3560 审计详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-20 17:10:46" itemprop="dateCreated datePublished" datetime="2020-02-20T17:10:46+08:00">2020-02-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>CodeQL 是一个白盒源代码审计工具，去年在这一领域掀起了一些波澜。其开发公司 Semmle 也成功和 Github 联姻，成立了 Github Security Lab，负责 Github 上开源软件的代码安全审计。同时还推出了面向社区和企业的源代码分析服务平台 LGTM，一派生机勃勃的景象。不过国内安全社区对 CodeQL 似乎还没有足够的讨论，网上零星有几篇文章也主要是安装配置和简单上手体验。</p>
<p>那么，CodeQL 有哪些核心能力？安全从业者能怎样运用它？它能给企业带来更大的价值吗？等等。这些都是我初见 CodeQL 时产生的疑问。在这篇文章中，我将从实际落地应用的角度出发，通过对一个漏洞实例的具体审计分析思路溯源来展示白盒审计中的一些关键问题，进而谈谈我对于 CodeQL 若干问题的个人看法。</p>
<a id="more"></a>

<h2 id="2-CodeQL-工作流程"><a href="#2-CodeQL-工作流程" class="headerlink" title="2. CodeQL 工作流程"></a>2. CodeQL 工作流程</h2><p>CodeQL 的整体工作流程如下图所示：<br><img src="/images/blog_pic/2020-02-20_1.png" alt="codeql_workflow"><br>(图片来源：<a target="_blank" rel="noopener" href="https://blog.semmle.com/introduction-to-variant-analysis-part-2/">https://blog.semmle.com/introduction-to-variant-analysis-part-2/</a>)</p>
<p>CodeQL 的整体思路是把源代码转化成一个可查询的数据库，通过 Extractor 模块对源代码工程进行关键信息分析提取，构成一个关系型数据库。CodeQL 的数据库并没有使用现有的数据库技术，而是一套基于文件的自己的实现。</p>
<p>对于编译型语言，Extractor 会监控编译过程，编译器每处理一个源代码文件，它都会收集源代码的相关信息，如：语法信息（AST 抽象语法树）、语意信息（名称绑定、类型信息、运算操作等），控制流、数据流等，同时也会复制一份源代码文件。而对于解释性语言，Extractor 则直接分析源代码，得到类似的相关信息。</p>
<p>关键信息提取完成后，所有分析所需的数据都会导入一个文件夹，这个就是 CodeQL database, 其中包括了源代码文件、关系数据、语言相关的 database schema（schema 定义了数据之间的相互关系）。</p>
<p>接下来就可以对数据库进行查询了，CodeQL 自己定义实现了一套名为 QL 的查询语言，并提供了相应的支持库和运行环境。</p>
<p>最终将查询结果展示给用户，方便用户进行进一步的人工审计分析。</p>
<h2 id="3-CodeQL-构成概述"><a href="#3-CodeQL-构成概述" class="headerlink" title="3. CodeQL 构成概述"></a>3. CodeQL 构成概述</h2><p>CodeQL 的核心功能主要涉及两个工程：</p>
<p>codeql-cli-binaries:<br><a target="_blank" rel="noopener" href="https://github.com/github/codeql-cli-binaries">https://github.com/github/codeql-cli-binaries</a></p>
<p>ql:<br><a target="_blank" rel="noopener" href="https://github.com/Semmle/ql">https://github.com/Semmle/ql</a></p>
<p>codeql-cli-binaries 工程是 CodeQL 的命令行工具，实现了 CodeQL 的大部分核心功能，包括 Extractor（不同目标语言对应着不同的 Extractor）、中间语言转换、AST 提取、控制流分析、数据流分析等，这个工程的核心模块都只提供 binary，并不开放源代码。</p>
<p>ql 工程是 QL 查询语言的实现，QL 是一种面向对象的高级语言，其支持库中封装了程序分析所需的所有对象及常用方法。这个在下个章节的漏洞实例审计分析中会使用到。</p>
<p>另外还有两个不太重要工程：</p>
<p>vscode-codeql:<br><a target="_blank" rel="noopener" href="https://github.com/github/vscode-codeql">https://github.com/github/vscode-codeql</a></p>
<p>vscode-codeql-starter：<br><a target="_blank" rel="noopener" href="https://github.com/github/vscode-codeql-starter">https://github.com/github/vscode-codeql-starter</a></p>
<p>vscode-codeql 是 CodeQL 的 VS Code 插件，它主要是为了方便在 VS Code 做结果展示用的; vscode-codeql-starter 工程是配合 VS Code 使用的一个 Workspace，它主要是为了方便配置，用户也完全可以自己配置 Workspace。</p>
<h2 id="4-CVE-2019-3560-审计详解"><a href="#4-CVE-2019-3560-审计详解" class="headerlink" title="4. CVE-2019-3560 审计详解"></a>4. CVE-2019-3560 审计详解</h2><p>关于 CodeQL 工具的安装配置，QL 开发环境的配置等内容，这些都不算是问题，本文就不赘述了。在这一部分中，我将详细分析一下 CVE-2019-3560 的审计思路。</p>
<h3 id="4-1-漏洞简介"><a href="#4-1-漏洞简介" class="headerlink" title="4.1. 漏洞简介"></a>4.1. 漏洞简介</h3><p>CVE-2019-3560 是 Semmle 研究员 Kevin Backhouse 发现的一个 Facebook Fizz 公共库的整数溢出漏洞，Fizz 是 Facebook 自己的 TLS 协议开源实现，使用 C++ 编写，大量应用于 Facebook 的网络基础设施中，具有重要的意义。</p>
<p>虽然这个漏洞只能造成 DoS 效果，但是是由于攻击者可以以极小的成本直接打服务端，使得使用了 TLS 协议的服务直接瘫痪，Facebook 仍为这个漏洞支付了一万美元的奖金。</p>
<h3 id="4-2-漏洞成因"><a href="#4-2-漏洞成因" class="headerlink" title="4.2. 漏洞成因"></a>4.2. 漏洞成因</h3><p>漏洞发生在 <a target="_blank" rel="noopener" href="https://github.com/facebookincubator/fizz/blob/eaa81af854bef509c3c1d7c83df0cd0b084a0fef/fizz/record/PlaintextRecordLayer.cpp#L42">PlaintextRecordLayer.cpp</a> 42 行的 <code>+=</code> 操作，这里有一个整数溢出问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">38</span>  <span class="keyword">auto</span> length = cursor.readBE&lt;<span class="keyword">uint16_t</span>&gt;();</span><br><span class="line"><span class="number">39</span>  <span class="keyword">if</span> (buf.chainLength() &lt; (cursor - buf.front()) + length) &#123;</span><br><span class="line"><span class="number">40</span>   <span class="keyword">return</span> folly::none;</span><br><span class="line"><span class="number">41</span>  &#125;</span><br><span class="line"><span class="number">42</span>  length +=</span><br><span class="line"><span class="number">43</span>      <span class="keyword">sizeof</span>(ContentType) + <span class="keyword">sizeof</span>(ProtocolVersion) + <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>);</span><br><span class="line"><span class="number">44</span>  buf.trimStart(length);</span><br><span class="line"><span class="number">45</span>  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码是如下函数的核心部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">folly::Optional&lt;TLSMessage&gt; <span class="title">PlaintextReadRecordLayer::read</span><span class="params">(folly::IOBufQueue&amp; buf)</span></span></span><br></pre></td></tr></table></figure>

<p>它是 TLS 记录层的一部分实现，<code>buf</code> 是由客户端传来的网络数据。</p>
<p>38 行从传入的网络数据包中读取了一个 <code>uint16_t</code> 值，并赋值给 <code>length</code>，也就是说 <code>length</code> 是攻击者可控的。<code>uint16_t</code> 是一个 <code>unsigned short int</code>, 大小是 <code>2 bytes</code>，取值范围是 <code>0~65535(0~0xFFFF)</code>；</p>
<p>42 行 <code>ContentType</code> 是一个枚举值，数据类型是 <code>uint8_t</code>，<code>1 bytes</code>，<code>ProtocolVersion</code> 也是枚举值，数据类型是 <code>uint16_t</code>，<code>2 bytes</code>，所以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(ContentType) + <span class="keyword">sizeof</span>(ProtocolVersion) + <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>) = <span class="number">5</span> bytes</span><br></pre></td></tr></table></figure>

<p>由于 <code>length</code> 攻击者可控，则令 <code>length == 0xFFFB</code> 即可使 <code>length</code> 发生整数溢出，使得 <code>length</code> 结果为 0:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">usinged <span class="title">long</span> <span class="params">(<span class="number">0xFFFB</span> + <span class="number">0x05</span>)</span> </span>= <span class="function">usinged <span class="title">short</span> <span class="params">(<span class="number">0x00</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>43 行 <code>buf</code> 是一个 <code>folly::IOBufQueue</code> 对象，这里调用了它的 <code>trimStart</code> 方法，其作用是向后移动 <code>buf</code> 数据指针。</p>
<p>整体这段代码在一个 <code>while</code> 循环里，通过 <code>trimStart</code> 不断向后移动数据指针来完成对 <code>buf</code> 中数据的处理。</p>
<p>39 行是一个边界检查，判断指针有没有移动到 <code>buf</code> 末尾，如果已经到了末尾，则表示数据处理完成，直接返回退出循环。</p>
<p>结合 42 行，如果 <code>length</code> 为 0，则 <code>trimStart</code> 操作无法移动 <code>buf</code> 指针，这样整段代码就会一直处理当前数据块，死循环了。</p>
<h3 id="4-3-构建-CodeQL-数据库"><a href="#4-3-构建-CodeQL-数据库" class="headerlink" title="4.3. 构建 CodeQL 数据库"></a>4.3. 构建 CodeQL 数据库</h3><p>在进行 CodeQL 审计之前，我们需要构建目标程序的数据库。这里只说明一下其中的两个关键点。</p>
<p>编译有漏洞的 Fizz 库：<br>这个漏洞补丁的 revision id 是 <a target="_blank" rel="noopener" href="https://github.com/facebookincubator/fizz/commit/40bbb161e72fb609608d53b9d64c56bb961a6ee2">40bbb16</a>，我们可以 checkout 切换到它的上一次提交的代码来编译。</p>
<p>创建 CodeQL 数据库：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql database create &lt;database_path&gt; --language=cpp --command=&#x27;&lt;build_command&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>这样 CodeQL 就会调用编译命令去编译目标工程，同时监控编译过程，调用 CPP 的 Extractor 去提取相关信息。</p>
<h3 id="4-4-CodeQL-漏洞建模"><a href="#4-4-CodeQL-漏洞建模" class="headerlink" title="4.4. CodeQL 漏洞建模"></a>4.4. CodeQL 漏洞建模</h3><p>通过上面的分析可以知道，42 行处进行了一个长整型到短整型的赋值运算，如果 <code>length &gt;= 0xFFFB</code>，就会发生整数溢出，导致死循环。</p>
<p>那么，问题的关键点就是：如何判断 <code>length</code> 是否是攻击者可控？</p>
<h4 id="4-4-1-建模思路"><a href="#4-4-1-建模思路" class="headerlink" title="4.4.1 建模思路"></a>4.4.1 建模思路</h4><p>我们来看一下 CodeQL 是如何找到这个用户可控的输入点的。</p>
<p>CodeQL 具有污点分析的能力，即如果我们能定义一个输入点 source，一个目标点 sink，就可以借助 CodeQL 去判断这两点之间是否存在数据流通路。</p>
<p>这里 sink 是一个整数溢出的模式，比较好定义，大整型转小整型、有符号转无符号等情况，都有可能出现整数溢出的问题。</p>
<p>source 就比较难定义了，我们需要定义一个模型来找出用户输入能够控制到的变量，这就要更具审计目标工程的具体实现来确定了。</p>
<p>具体到 Fizz，它使用了 Facebook 的一个基础 C++ 类库 folly，使用了 <code>folly::IOBufQueue</code> 来存储接收到的网络数据，所以比较直接的思路是将 <code>folly::IOBufQueue</code> 对象定义为 source。</p>
<p>不过 semmle 的研究员给出了一个更通用的思路，在 Fizz 的场景下，网络数据是不安全的输入，那么问题就转化为了如何准确定义网络接收的数据？当数据通过 socket 发送时，通常是以 <code>network byte order</code> 发送的，服务端在接收到之后，需要转换为 <code>host bytes order</code>，这一般是通过 <code>ntohs/ntohl (Network to Host Short/Long)</code> 函数实现的。<code>network byte order</code> 是小端序，x86 架构下的 <code>host byte order</code> 是大端序，即 host 在接收到网络发来的数据后，需要将其从小端序转换为大端序。Fizz 工程中并没有调用标准库的 <code>ntohs/ntohl</code> 函数来实现这一功能，而是调用的 folly 基础类库的 <code>folly::Endian::big</code> 函数来实现，功能相同。所以，我们就可以将 <code>folly::Endian::big</code> 函数的调用定义为 source，即做了大小端转换的操作的数据基本可以认为是接收的网络数据。</p>
<h4 id="4-4-2-QL-建模实现"><a href="#4-4-2-QL-建模实现" class="headerlink" title="4.4.2 QL 建模实现"></a>4.4.2 QL 建模实现</h4><p>接下来就需要用 CodeQL 的查询语言 QL 来描述我们定义的模型。</p>
<p>首先导入需要用到的库：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.ir.dataflow.TaintTracking</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.ir.IR</span><br><span class="line"><span class="keyword">import</span> DataFlow::PathGraph</span><br></pre></td></tr></table></figure>

<p>这里用到了 cpp 核心库、污点跟踪库、中间语言库、数据流分析库。</p>
<p>接着定义 <code>folly::Endian::big</code> 函数的匹配方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EndianConvert</span> <span class="title">extends</span> <span class="title">Function</span> &#123;</span></span><br><span class="line">  EndianConvert() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getName() = <span class="string">&quot;big&quot;</span> <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">this</span>.getDeclaringType().getName().matches(<span class="string">&quot;Endian&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>folly::Endian::big</code> 函数的匹配来定义网络数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">isNetworkData</span><span class="params">(Instruction i)</span> </span>&#123;</span><br><span class="line">  i.(CallInstruction).getCallTarget().(FunctionInstruction).getFunctionSymbol() instanceof</span><br><span class="line">    EndianConvert</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个判断危险整型转换的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">isNarrowingConversion</span><span class="params">(ConvertInstruction i)</span> </span>&#123;</span><br><span class="line">  i.getResultSize() &lt; i.getUnary().getResultSize()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里就体现出了中间语言表示的价值，通过中间语言的统一表示，我们可以用 CodeQL 库里的 <code>ConvertInstruction</code> 来统一匹配所有类型的数据转换操作。</p>
<p>再通过上面的判断方法来定义污点分析的 source 和 sink：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cfg</span> <span class="title">extends</span> <span class="title">TaintTracking</span>:</span>:Configuration &#123;</span><br><span class="line">  Cfg() &#123; <span class="keyword">this</span> = <span class="string">&quot;FizzOverflowIR&quot;</span> &#125;</span><br><span class="line">  <span class="keyword">override</span> predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    isNetworkData(source.asInstruction())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    isNarrowingConversion(sink.asInstruction())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终做查找和输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from</span><br><span class="line">  Cfg cfg, DataFlow::PathNode source, DataFlow::PathNode sink, ConvertInstruction conv,</span><br><span class="line">  Type inputType, Type outputType</span><br><span class="line">where</span><br><span class="line">  cfg.hasFlowPath(source, sink) <span class="keyword">and</span></span><br><span class="line">  conv = sink.getNode().asInstruction() <span class="keyword">and</span></span><br><span class="line">  inputType = conv.getUnary().getResultType() <span class="keyword">and</span></span><br><span class="line">  outputType = conv.getResultType()</span><br><span class="line">select sink, source,</span><br><span class="line">  <span class="string">&quot;Conversion of untrusted data from &quot;</span> + inputType + <span class="string">&quot; to &quot;</span> + outputType + <span class="string">&quot;.&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里最核心的判断是通过污点分析来判断我们定义的 surce 和 sink 之间是否有数据流通路。</p>
<p>通过这个查询，可以在 Fizz 工程中找到筛选出三个问题，如下图所示：<img src="/images/blog_pic/2020-02-20_2.png" alt="ql_result"></p>
<p>其中，第三个就是 CVE-2019-3560 的漏洞点。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>写到这里，我们对 CodeQL 已经有了一个比较具体的认识。在这一部分，我想通过几个直截了当的问题来对 CodeQL 做一个大致的总结。</p>
<ol>
<li><p>CodeQL 的这些能力是它独有的吗？<br>当然不是。白盒代码审计并不是新的领域，业界已经有非常多的工具。老牌商业软件如 Fortify SCA, Coverity，开源工具更多，各大互联网公司也都会建设自己的源代码安全审计平台，这里就不一一列举了。以 Fortify 为例， 其产品白皮书中就说明了它的五大主要分析引擎：数据流、语义、结构、控制流、配置流。各家也都在做，学术界研究的也不少。</p>
</li>
<li><p>CodeQL 有什么优势？<br>简单说就是免费、开源、Semmle 团队强大的研究能力。Semmle 孵化于牛津大学, 其投资者包括 Google, Microsoft, NASA 等，现在又加入了 Github，这样闪光的履历其实也是能力的背书。具体讲，CodeQL 的基础功能扎实，迭代迅速，又不断有研究员发高水平的文章，这些都是它的优势。</p>
</li>
<li><p>CodeQL 能给白盒领域带来突破性的发展吗？<br>这个不一定。从本文的漏洞实例分析中你也可以看出，白盒审计最重要的能力是对安全模型的认识和对分析目标的理解。傻瓜一键式的工具是不存在的，或者换种说法，简单问题现有工具就能解决了。所以核心还是人。</p>
</li>
<li><p>CodeQL 对我们有什么价值？<br>分两方面。<br>对个人而言，意味者被赋能了更复杂的代码分析能力。越是困难的问题，基础工具的能力越是重要，这在各个领域都是相通的。比如在二进制软件分析领域，近年来在 Intel PT 技术等基础能力的加持下，就有了非常迅速的发展。<br>对企业而言，目前互联网公司的白盒代码审计多是采用采购商业软件 + 自研工具的方式，那我认为 CodeQL 当然是一个很重要的技术选型目标。</p>
</li>
<li><p>CodeQL 更适用于哪些场景？<br>更适用于对复杂安全问题的建模。Fortify 之类的老牌商业软件更重要的是它的规则库，更适合做大规模、通用型问题的扫描。CodeQL 当然也可以这样用，但我认为它更适合的场景是做复杂安全问题的建模，在对审计目标有足够理解的基础之上做针对性的安全分析。</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.semmle.com/introduction-to-variant-analysis-part-2/">Introduction to variant analysis with QL and LGTM (part 2)</a></li>
<li><a target="_blank" rel="noopener" href="https://securitylab.github.com/research/facebook-fizz-CVE-2019-3560">Facebook Fizz integer overflow vulnerability (CVE-2019-3560)</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/fizz-memory-leak-analysis/" rel="next" title="Facebook Fizz memory leak vulnerability (CVE-2019-11924) reproduce and analysis">
      Facebook Fizz memory leak vulnerability (CVE-2019-11924) reproduce and analysis <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%83%8C%E6%99%AF"><span class="nav-text">1. 背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-CodeQL-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">2. CodeQL 工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-CodeQL-%E6%9E%84%E6%88%90%E6%A6%82%E8%BF%B0"><span class="nav-text">3. CodeQL 构成概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-CVE-2019-3560-%E5%AE%A1%E8%AE%A1%E8%AF%A6%E8%A7%A3"><span class="nav-text">4. CVE-2019-3560 审计详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B"><span class="nav-text">4.1. 漏洞简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="nav-text">4.2. 漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%9E%84%E5%BB%BA-CodeQL-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">4.3. 构建 CodeQL 数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-CodeQL-%E6%BC%8F%E6%B4%9E%E5%BB%BA%E6%A8%A1"><span class="nav-text">4.4. CodeQL 漏洞建模</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E5%BB%BA%E6%A8%A1%E6%80%9D%E8%B7%AF"><span class="nav-text">4.4.1 建模思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-QL-%E5%BB%BA%E6%A8%A1%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.4.2 QL 建模实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93"><span class="nav-text">5.总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lenny Wang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Lenny Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lennysec" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lennysec" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/lywang90" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;lywang90" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/lywang90" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;lywang90" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-bolt"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lenny Wang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
